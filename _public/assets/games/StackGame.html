<!DOCTYPE html>
<html lang="zh">
	<head>
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
		<title>å çŸ³å¤´å°æ¸¸æˆ</title>
<style>
  * {
    box-sizing: border-box;
  }
  
  body { 
    margin: 0; 
    display: flex; 
    justify-content: center; 
    align-items: center; 
    height: 100vh; 
    background: linear-gradient(135deg, #b8d8e8 0%, #87ceeb 50%, #6bb6d6 100%); 
    touch-action: none;
    font-family: Arial, sans-serif;
  }
  
  #gameContainer {
    position: relative;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 15px;
  }
  
  canvas { 
    background-color: #f0f4f8; 
    box-shadow: 0 12px 40px rgba(0,0,0,0.15); 
    border-radius: 12px;
    display: block;
    cursor: pointer;
  }
  
  #stats {
    color: white;
    text-align: center;
    font-size: 18px;
    min-height: 50px;
  }
  
  #stats div {
    margin: 5px 0;
  }
  
  .score { font-size: 24px; font-weight: bold; }
  .high-score { font-size: 14px; opacity: 0.9; }
  
  @media (max-width: 400px) {
    canvas {
      width: 100%;
      height: auto;
      max-width: 320px;
    }
  }
</style>
	</head>
	<body>
    <div id="gameContainer">
      <canvas id="gameCanvas" width="320" height="500"></canvas>
      <div id="stats">
        <div class="score">åˆ†æ•°: <span id="scoreValue">0</span></div>
        <div class="high-score">æœ€é«˜åˆ†: <span id="highScoreValue">0</span></div>
      </div>
    </div>

		<script>
      // ==================== Game Configuration ====================
      const COLORS = {
        stone: '#3498db',
        moving: '#e74c3c',
        stoneStroke: '#2c3e50',
        gameoverText: '#e74c3c'
      };
      
      // ==================== Audio Setup ====================
      const audioContext = new (window.AudioContext || window.webkitAudioContext)();
      
      function playSound(frequency, duration, type = 'sine') {
        const now = audioContext.currentTime;
        const osc = audioContext.createOscillator();
        const gain = audioContext.createGain();
        
        osc.connect(gain);
        gain.connect(audioContext.destination);
        
        osc.frequency.value = frequency;
        osc.type = type;
        
        gain.gain.setValueAtTime(0.1, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + duration);
        
        osc.start(now);
        osc.stop(now + duration);
      }
      
      function playSuccessSound() {
        playSound(523, 0.1); // C5
        setTimeout(() => playSound(659, 0.1), 80); // E5
      }
      
      function playGameOverSound() {
        playSound(200, 0.2);
        setTimeout(() => playSound(150, 0.3), 150);
      }
      
      function playStageUpSound() {
        playSound(523, 0.15); // C5
        setTimeout(() => playSound(659, 0.15), 100); // E5
        setTimeout(() => playSound(784, 0.2), 200); // G5
      }

      // ==================== Particle System ====================
      class Particle {
        constructor(x, y) {
          this.x = x;
          this.y = y;
          this.vx = (Math.random() - 0.5) * 6;
          this.vy = (Math.random() - 0.5) * 6 - 2;
          this.life = 1;
          this.size = Math.random() * 8 + 4;
        }
        
        update() {
          this.x += this.vx;
          this.y += this.vy;
          this.vy += 0.2; // gravity
          this.life -= 0.02;
          return this.life > 0;
        }
        
        draw(ctx) {
          ctx.fillStyle = `rgba(100, 200, 100, ${this.life * 0.6})`;
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
          ctx.fill();
        }
      }
      
      class FloatingScore {
        constructor(x, y, text) {
          this.x = x;
          this.y = y;
          this.text = text;
          this.life = 1;
          this.vy = -1.5;
        }
        
        update() {
          this.y += this.vy;
          this.life -= 0.025;
          return this.life > 0;
        }
        
        draw(ctx) {
          ctx.save();
          ctx.fillStyle = `rgba(76, 175, 80, ${this.life})`;
          ctx.font = `bold ${20 + this.life * 10}px Arial`;
          ctx.textAlign = 'center';
          ctx.fillText(this.text, this.x, this.y);
          ctx.restore();
        }
      }

      // ==================== Game State ====================
      const canvas = document.getElementById('gameCanvas');
      const ctx = canvas.getContext('2d');
      
      // Stage system - difficulty increases by score milestones
      const STAGES = [
        { minScore: 0, label: 'é’é“œ', icon: 'ğŸ¥‰', speedMultiplier: 1, minOverlap: 0.35, color: '#CD7F32' },
        { minScore: 4, label: 'ç™½é“¶', icon: 'ğŸ¥ˆ', speedMultiplier: 1.15, minOverlap: 0.32, color: '#C0C0C0' },
        { minScore: 9, label: 'é»„é‡‘', icon: 'ğŸ¥‡', speedMultiplier: 1.35, minOverlap: 0.28, color: '#FFD700' },
        { minScore: 16, label: 'é“‚é‡‘', icon: 'ğŸ’', speedMultiplier: 1.6, minOverlap: 0.23, color: '#E5E4E2' },
        { minScore: 26, label: 'é’»çŸ³', icon: 'ğŸ’ ', speedMultiplier: 1.85, minOverlap: 0.18, color: '#00CED1' },
        { minScore: 40, label: 'ç‹è€…', icon: 'ğŸ‘‘', speedMultiplier: 2.2, minOverlap: 0.13, color: '#FF6B9D' }
      ];
      
      function getCurrentStage() {
        for (let i = STAGES.length - 1; i >= 0; i--) {
          if (gameState.score >= STAGES[i].minScore) {
            return STAGES[i];
          }
        }
        return STAGES[0];
      }
      
      let gameState = {
        stones: [{x: 60, y: 450, w: 200, h: 40}],
        movingStone: {x: 0, y: 410, w: 200, h: 40, speed: 2.5, dir: 1},
        score: 0,
        highScore: localStorage.getItem('stackGameHighScore') || 0,
        gameOver: false,
        gameOverFadeIn: 0,
        gameStarted: false,
        previousStage: null,
        stageCelebrationTimer: 0,
        dropEffect: null,
        particles: [],
        floatingScores: [],
        shakeAmount: 0,
        movingStoneFloat: 0,
        successFlash: 0
      };

      // ==================== Drawing ====================
      function drawMarble(x, y, w, h, color = COLORS.stone, isMoving = false) {
        // Draw as a 3D marble/sphere stack effect
        const marbleHeight = h;
        const marbleWidth = w;
        const centerX = x + marbleWidth / 2;
        const centerY = y + marbleHeight / 2;
        
        // Draw base shadow
        ctx.fillStyle = 'rgba(0, 0, 0, 0.25)';
        ctx.beginPath();
        ctx.ellipse(centerX, y + marbleHeight + 3, marbleWidth / 2, 4, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Create marble appearance with radial gradient
        const marbleGradient = ctx.createRadialGradient(centerX - marbleWidth / 6, centerY - marbleHeight / 5, 2, centerX, centerY, marbleWidth / 2);
        marbleGradient.addColorStop(0, lightenColor(color, 40));
        marbleGradient.addColorStop(0.4, color);
        marbleGradient.addColorStop(0.7, darkenColor(color, 30));
        marbleGradient.addColorStop(1, darkenColor(color, 50));
        
        ctx.fillStyle = marbleGradient;
        ctx.fillRect(x, y, w, h);
        
        // Add glossy highlight
        const highlightGradient = ctx.createLinearGradient(x, y, x, y + h / 3);
        highlightGradient.addColorStop(0, 'rgba(255, 255, 255, 0.4)');
        highlightGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
        ctx.fillStyle = highlightGradient;
        ctx.fillRect(x, y, w, h / 3);
        
        // Add subtle texture variations
        ctx.fillStyle = 'rgba(0, 0, 0, 0.03)';
        for (let i = 0; i < 8; i++) {
          ctx.fillRect(x + Math.random() * w, y + Math.random() * h, Math.random() * 3, Math.random() * 3);
        }
        
        // Dark edge for depth
        ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
        ctx.lineWidth = 2;
        ctx.strokeRect(x, y, w, h);
        
        // Extra highlight for moving marble
        if (isMoving) {
          ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
          ctx.lineWidth = 1;
          ctx.strokeRect(x + 3, y + 3, w - 6, h - 6);
        }
      }
      
      function lightenColor(color, amount) {
        const rgb = hexToRgb(color) || hslToRgb(color);
        if (!rgb) return color;
        return `rgb(${Math.min(255, rgb.r + amount)}, ${Math.min(255, rgb.g + amount)}, ${Math.min(255, rgb.b + amount)})`;
      }
      
      function darkenColor(color, amount) {
        const rgb = hexToRgb(color) || hslToRgb(color);
        if (!rgb) return color;
        return `rgb(${Math.max(0, rgb.r - amount)}, ${Math.max(0, rgb.g - amount)}, ${Math.max(0, rgb.b - amount)})`;
      }
      
      function hexToRgb(hex) {
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? {
          r: parseInt(result[1], 16),
          g: parseInt(result[2], 16),
          b: parseInt(result[3], 16)
        } : null;
      }
      
      function hexToRgbString(hex) {
        const rgb = hexToRgb(hex);
        return rgb ? `${rgb.r}, ${rgb.g}, ${rgb.b}` : '255, 255, 255';
      }
      
      function hslToRgb(hsl) {
        const match = hsl.match(/hsl\((\d+),\s*(\d+)%,\s*(\d+)%\)/);
        if (!match) return null;
        
        let h = match[1] / 360;
        let s = match[2] / 100;
        let l = match[3] / 100;
        
        let r, g, b;
        if (s === 0) {
          r = g = b = l;
        } else {
          const hue2rgb = (p, q, t) => {
            if (t < 0) t += 1;
            if (t > 1) t -= 1;
            if (t < 1/6) return p + (q - p) * 6 * t;
            if (t < 1/2) return q;
            if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
            return p;
          };
          const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
          const p = 2 * l - q;
          r = hue2rgb(p, q, h + 1/3);
          g = hue2rgb(p, q, h);
          b = hue2rgb(p, q, h - 1/3);
        }
        
        return {
          r: Math.round(r * 255),
          g: Math.round(g * 255),
          b: Math.round(b * 255)
        };
      }

      function draw() {
        // Apply screen shake (but not on game over)
        ctx.save();
        if (gameState.shakeAmount > 0 && !gameState.gameOver) {
          const shakeX = (Math.random() - 0.5) * gameState.shakeAmount;
          const shakeY = (Math.random() - 0.5) * gameState.shakeAmount;
          ctx.translate(shakeX, shakeY);
        }

        // Draw calm sea waves background
        // Sky gradient
        const skyGradient = ctx.createLinearGradient(0, 0, 0, canvas.height * 0.4);
        skyGradient.addColorStop(0, '#e8f4f8');
        skyGradient.addColorStop(1, '#d0e8f0');
        ctx.fillStyle = skyGradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height * 0.4);
        
        // Water gradient
        const waterGradient = ctx.createLinearGradient(0, canvas.height * 0.4, 0, canvas.height);
        waterGradient.addColorStop(0, '#a8d8ea');
        waterGradient.addColorStop(0.5, '#7ecfe4');
        waterGradient.addColorStop(1, '#5cbfd9');
        ctx.fillStyle = waterGradient;
        ctx.fillRect(0, canvas.height * 0.4, canvas.width, canvas.height * 0.6);
        
        // Draw animated waves
        const time = Date.now() * 0.001; // Current time in seconds
        const waveHeight = 8;
        const waveFrequency = 0.015;
        
        // Wave layers for depth effect
        for (let waveLayer = 0; waveLayer < 3; waveLayer++) {
          const waveY = canvas.height * 0.4 + (waveLayer * 15);
          const layerAlpha = 0.5 - (waveLayer * 0.15);
          const layerSpeed = 1 + (waveLayer * 0.3);
          
          ctx.strokeStyle = `rgba(230, 245, 250, ${layerAlpha})`;
          ctx.lineWidth = 3;
          ctx.beginPath();
          
          for (let x = 0; x <= canvas.width; x += 5) {
            const y = waveY + Math.sin((x * waveFrequency) + (time * layerSpeed)) * waveHeight;
            if (x === 0) {
              ctx.moveTo(x, y);
            } else {
              ctx.lineTo(x, y);
            }
          }
          
          ctx.stroke();
        }
        
        // Add light shimmer effect on water
        ctx.save();
        ctx.fillStyle = 'rgba(255, 255, 255, 0.08)';
        ctx.beginPath();
        ctx.arc(canvas.width / 2 + Math.sin(time * 0.5) * 20, canvas.height * 0.5, 40, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();

        // Draw guide line
        ctx.strokeStyle = 'rgba(100, 180, 200, 0.25)';
        ctx.setLineDash([5, 5]);
        ctx.beginPath();
        ctx.moveTo(0, gameState.movingStone.y + gameState.movingStone.h);
        ctx.lineTo(canvas.width, gameState.movingStone.y + gameState.movingStone.h);
        ctx.stroke();
        ctx.setLineDash([]);

        // Draw stage indicator with rank styling
        const currentStage = getCurrentStage();
        const stageX = canvas.width - 115;
        const stageY = 12;
        const stageBgWidth = 110;
        const stageBgHeight = 70;
        const cornerRadius = 12;
        
        // Draw rounded rectangle background with shadow
        ctx.save();
        ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
        ctx.shadowBlur = 8;
        ctx.shadowOffsetX = 2;
        ctx.shadowOffsetY = 2;
        
        // Draw rounded background
        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        ctx.beginPath();
        ctx.moveTo(stageX + cornerRadius, stageY);
        ctx.lineTo(stageX + stageBgWidth - cornerRadius, stageY);
        ctx.quadraticCurveTo(stageX + stageBgWidth, stageY, stageX + stageBgWidth, stageY + cornerRadius);
        ctx.lineTo(stageX + stageBgWidth, stageY + stageBgHeight - cornerRadius);
        ctx.quadraticCurveTo(stageX + stageBgWidth, stageY + stageBgHeight, stageX + stageBgWidth - cornerRadius, stageY + stageBgHeight);
        ctx.lineTo(stageX + cornerRadius, stageY + stageBgHeight);
        ctx.quadraticCurveTo(stageX, stageY + stageBgHeight, stageX, stageY + stageBgHeight - cornerRadius);
        ctx.lineTo(stageX, stageY + cornerRadius);
        ctx.quadraticCurveTo(stageX, stageY, stageX + cornerRadius, stageY);
        ctx.closePath();
        ctx.fill();
        
        // Draw colored border
        ctx.strokeStyle = currentStage.color;
        ctx.lineWidth = 3;
        ctx.stroke();
        
        ctx.restore();
        
        // Draw rank icon (larger)
        ctx.font = 'bold 32px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(currentStage.icon, stageX + stageBgWidth / 2, stageY + 22);
        
        // Draw rank label (white text, high contrast)
        ctx.font = 'bold 14px Arial';
        ctx.fillStyle = '#ffffff';
        ctx.fillText(currentStage.label, stageX + stageBgWidth / 2, stageY + 52);
        ctx.textAlign = 'left';

        // Draw placed stones with marble appearance
        for (let i = 0; i < gameState.stones.length; i++) {
          const s = gameState.stones[i];
          const hue = (i * 15) % 360;
          const color = `hsl(${hue}, 70%, 50%)`;
          drawMarble(s.x, s.y, s.w, s.h, color);
        }

        // Draw moving stone with floating animation
        if (!gameState.gameOver) {
          const floatOffset = Math.sin(Date.now() / 200) * 2;
          drawMarble(gameState.movingStone.x, gameState.movingStone.y + floatOffset, 
                    gameState.movingStone.w, gameState.movingStone.h, 
                    COLORS.moving, true);
        }

        // Draw particles
        gameState.particles = gameState.particles.filter(p => {
          p.update();
          p.draw(ctx);
          return p.life > 0;
        });

        // Draw stage celebration banner (top announcement)
        if (gameState.stageCelebrationTimer > 0) {
          const progress = 1 - (gameState.stageCelebrationTimer / 60);
          const alpha = progress < 0.2 ? progress * 5 : (1 - Math.max(0, (progress - 0.85) * 6.67));
          
          // Draw banner background with rank color
          const bannerHeight = 80;
          const bannerY = 15;
          ctx.fillStyle = `rgba(${hexToRgbString(currentStage.color)}, ${alpha * 0.7})`;
          ctx.fillRect(20, bannerY, canvas.width - 40, bannerHeight);
          
          // Border
          ctx.strokeStyle = `rgba(${hexToRgbString(currentStage.color)}, ${alpha})`;
          ctx.lineWidth = 3;
          ctx.strokeRect(20, bannerY, canvas.width - 40, bannerHeight);
          
          // Icon and text
          ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
          ctx.font = `bold 20px Arial`;
          ctx.textAlign = 'center';
          ctx.fillText(`${currentStage.icon} å‡çº§åˆ°${currentStage.label}é˜¶æ®µ ${currentStage.icon}`, canvas.width / 2, bannerY + 50);
          
          gameState.stageCelebrationTimer--;
          ctx.textAlign = 'left';
        }

        // Draw floating scores
        gameState.floatingScores = gameState.floatingScores.filter(fs => {
          fs.update();
          fs.draw(ctx);
          return fs.life > 0;
        });

        // Draw success flash
        if (gameState.successFlash > 0) {
          ctx.fillStyle = `rgba(76, 175, 80, ${gameState.successFlash * 0.3})`;
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          gameState.successFlash -= 0.1;
        }

        // Draw game over screen with smooth fade-in
        if (gameState.gameOver) {
          // Smooth fade in effect
          gameState.gameOverFadeIn = Math.min(1, gameState.gameOverFadeIn + 0.05);
          const fadeAlpha = gameState.gameOverFadeIn;
          
          // Fade overlay
          ctx.fillStyle = `rgba(0, 0, 0, ${0.7 * fadeAlpha})`;
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          
          // Fade text
          ctx.globalAlpha = fadeAlpha;
          ctx.fillStyle = COLORS.gameoverText;
          ctx.font = 'bold 48px Arial';
          ctx.textAlign = 'center';
          ctx.fillText('æ¸¸æˆç»“æŸ!', canvas.width / 2, 160);
          
          ctx.font = '24px Arial';
          ctx.fillText('åˆ†æ•°: ' + gameState.score, canvas.width / 2, 220);
          
          // Show rank with icon and color
          ctx.font = 'bold 28px Arial';
          ctx.fillStyle = currentStage.color;
          ctx.fillText(currentStage.icon + ' ' + currentStage.label + ' ' + currentStage.icon, canvas.width / 2, 280);
          
          ctx.font = '14px Arial';
          ctx.fillStyle = '#ecf0f1';
          ctx.fillText('ç‚¹å‡»å±å¹•é‡æ–°å¼€å§‹', canvas.width / 2, 320);
          ctx.globalAlpha = 1;
          ctx.textAlign = 'left';
        }
        
        // Draw initial instruction screen
        if (!gameState.gameStarted) {
          ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          
          ctx.fillStyle = '#ecf0f1';
          ctx.font = 'bold 32px Arial';
          ctx.textAlign = 'center';
          ctx.fillText('å çŸ³å¤´', canvas.width / 2, 80);
          
          ctx.font = '16px Arial';
          ctx.fillText('ä»é’é“œåˆ°ç‹è€…ï¼ŒæŒ‘æˆ˜è‡ªå·±çš„æé™', canvas.width / 2, 120);
          
          ctx.font = '18px Arial';
          ctx.fillText('ç‚¹å‡»å±å¹•å¼€å§‹', canvas.width / 2, 200);
          ctx.fillText('å°†çŸ³å¤´å †å èµ·æ¥', canvas.width / 2, 240);
          ctx.fillText('æ¯å é«˜ä¸€å—åˆ†æ•°+1', canvas.width / 2, 280);
          
          // Show rank progression
          ctx.font = 'bold 14px Arial';
          ctx.fillStyle = 'rgba(236, 240, 241, 0.8)';
          ctx.fillText('æ®µä½è¿›åº¦: ğŸ¥‰ç™½é“¶ ğŸ¥‡é»„é‡‘ ğŸ’é“‚é‡‘ ğŸ’ é’»çŸ³ ğŸ‘‘ç‹è€…', canvas.width / 2, 350);
          
          ctx.textAlign = 'left';
        }

        ctx.restore();
      }

      // ==================== Game Logic ====================
      function update() {
        if (gameState.gameOver || !gameState.gameStarted) return;

        gameState.movingStone.x += gameState.movingStone.speed * gameState.movingStone.dir;
        
        // Bounce off walls
        if (gameState.movingStone.x <= 0 || gameState.movingStone.x + gameState.movingStone.w >= canvas.width) {
          gameState.movingStone.dir *= -1;
        }
        
        // Clamp position to stay within bounds
        gameState.movingStone.x = Math.max(0, Math.min(gameState.movingStone.x, canvas.width - gameState.movingStone.w));
        
        // Decay shake
        gameState.shakeAmount *= 0.92;
      }

      function resetGame() {
        gameState = {
          ...gameState,
          stones: [{x: 60, y: 450, w: 200, h: 40}],
          movingStone: {x: 0, y: 410, w: 200, h: 40, speed: 2.5, dir: 1},
          score: 0,
          gameOver: false,
          gameOverFadeIn: 0,
          gameStarted: false,
          previousStage: null,
          stageCelebrationTimer: 0,
          particles: [],
          floatingScores: [],
          shakeAmount: 0
        };
      }

      function placestone() {
        if (!gameState.gameStarted) {
          gameState.gameStarted = true;
          return;
        }

        if (gameState.gameOver) {
          resetGame();
          return;
        }

        const currentStage = getCurrentStage();
        const topStone = gameState.stones[gameState.stones.length - 1];
        const left = Math.max(gameState.movingStone.x, topStone.x);
        const right = Math.min(gameState.movingStone.x + gameState.movingStone.w, topStone.x + topStone.w);
        const overlap = right - left;
        const overlapPercentage = overlap / gameState.movingStone.w;

        // Check overlap against stage requirement
        if (overlapPercentage >= currentStage.minOverlap) {
          // Success
          gameState.stones.push({
            x: left,
            y: gameState.movingStone.y,
            w: overlap,
            h: gameState.movingStone.h
          });
          gameState.score++;
          
          // Check if stage changed
          const newStage = getCurrentStage();
          if (gameState.previousStage && newStage.minScore > gameState.previousStage.minScore) {
            // Stage up! Celebrate
            gameState.stageCelebrationTimer = 60;
            playStageUpSound();
            
            // Create lots of particles for celebration
            for (let i = 0; i < 30; i++) {
              gameState.particles.push(new Particle(canvas.width / 2, canvas.height / 2));
            }
          }
          gameState.previousStage = newStage;
          
          // Add visual feedback
          gameState.successFlash = 1;
          gameState.shakeAmount = 5;
          
          // Create particles at landing location
          for (let i = 0; i < 12; i++) {
            gameState.particles.push(new Particle(left + overlap / 2, gameState.movingStone.y + 20));
          }
          
          // Add floating score
          gameState.floatingScores.push(new FloatingScore(left + overlap / 2, gameState.movingStone.y - 20, '+1'));
          
          playSuccessSound();

          // Prepare next stone with stage-based difficulty
          let nextY = gameState.movingStone.y - 40;
          let nextW = overlap;
          let baseSpeed = 2.5 * currentStage.speedMultiplier + (gameState.score * 0.06); 
          let maxSpeed = 7;

          gameState.movingStone = {
            x: 0,
            y: nextY,
            w: nextW,
            h: 40,
            speed: Math.min(baseSpeed, maxSpeed),
            dir: 1
          };

          // Camera follow effect
          if (nextY < 150) {
            const shift = 40;
            gameState.stones.forEach(s => s.y += shift);
            gameState.movingStone.y += shift;
          }
        } else {
          // Game Over
          gameState.gameOver = true;
          gameState.shakeAmount = 10;
          playGameOverSound();
          
          // Update high score
          if (gameState.score > gameState.highScore) {
            gameState.highScore = gameState.score;
            localStorage.setItem('stackGameHighScore', gameState.highScore);
          }
        }
      }

      // ==================== Game Loop ====================
      function loop() {
        update();
        draw();
        
        // Update UI
        document.getElementById('scoreValue').textContent = gameState.score;
        document.getElementById('highScoreValue').textContent = gameState.highScore;
        
        requestAnimationFrame(loop);
      }

      // ==================== Event Handlers ====================
      canvas.addEventListener('pointerdown', () => {
        placestone();
      });

      // Keyboard support
      window.addEventListener('keydown', (e) => {
        if (e.code === 'Space' || e.code === 'Enter') {
          e.preventDefault();
          placestone();
        }
      });

      // Initialize - start with difficulty selection
      loop();
		</script>
	</body>
</html>

